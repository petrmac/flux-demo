receivers:
  otlp:
    protocols:
      grpc:
      http:
  opencensus:
  zipkin:
  jaeger:
    protocols:
      grpc:
      thrift_http:
      thrift_compact:
      thrift_binary:
  filelog:
    include:
      - /var/log/pods/*/*/*.log
    exclude:
      # Exclude logs from all containers named opentelemetry-collector
      - /var/log/pods/*/opentelemetry-collector/*.log
    start_at: beginning
    include_file_path: true
    include_file_name: false
    operators:
      # Find out which format is used by kubernetes
      - type: router
        id: get-format
        routes:
          - output: parser-docker
            expr: 'body matches "^\\{"'
          - output: parser-crio
            expr: 'body matches "^[^ Z]+ "'
          - output: parser-containerd
            expr: 'body matches "^[^ Z]+Z"'
      # Parse CRI-O format
      - type: regex_parser
        id: parser-crio
        regex: '^(?P<time>[^ Z]+) (?P<stream>stdout|stderr) (?P<logtag>[^ ]*) ?(?P<log>.*)$'
        output: extract_metadata_from_filepath
        timestamp:
          parse_from: attributes.time
          layout_type: gotime
          layout: '2006-01-02T15:04:05.000000000-07:00'
      # Parse CRI-Containerd format
      - type: regex_parser
        id: parser-containerd
        regex: '^(?P<time>[^ ^Z]+Z) (?P<stream>stdout|stderr) (?P<logtag>[^ ]*) ?(?P<log>.*)$'
        output: extract_metadata_from_filepath
        timestamp:
          parse_from: attributes.time
          layout: '%Y-%m-%dT%H:%M:%S.%LZ'
      # Parse Docker format
      - type: json_parser
        id: parser-docker
        output: extract_metadata_from_filepath
        timestamp:
          parse_from: attributes.time
          layout: '%Y-%m-%dT%H:%M:%S.%LZ'
      - type: move
        from: attributes.log
        to: body
      # Extract metadata from file path
      - type: regex_parser
        id: extract_metadata_from_filepath
        regex: '^.*\/(?P<namespace>[^_]+)_(?P<pod_name>[^_]+)_(?P<uid>[a-f0-9\-]{36})\/(?P<container_name>[^\._]+)\/(?P<restart_count>\d+)\.log$'
        parse_from: attributes["log.file.path"]
      # Rename attributes
      - type: move
        from: attributes.stream
        to: attributes["log.iostream"]
      - type: move
        from: attributes.container_name
        to: resource["k8s.container.name"]
      - type: move
        from: attributes.namespace
        to: resource["k8s.namespace.name"]
      - type: move
        from: attributes.pod_name
        to: resource["k8s.pod.name"]
      - type: move
        from: attributes.restart_count
        to: resource["k8s.container.restart_count"]
      - type: move
        from: attributes.uid
        to: resource["k8s.pod.uid"]
  hostmetrics:
    collection_interval: 10s
    scrapers:
      paging:
        metrics:
          system.paging.utilization:
            enabled: true
      cpu:
        metrics:
          system.cpu.utilization:
            enabled: true
      disk:
      filesystem:
        metrics:
          system.filesystem.utilization:
            enabled: true
      load:
      memory:
      network:
      processes:
processors:
  resource:
    attributes:
      - key: env
        value: "prod"
        action: upsert
      - key: service.namespace
        value: "crushlog"
        action: upsert
  batch:
    send_batch_max_size: 200
    send_batch_size: 100
    timeout: 5s
  groupbytrace/custom:
    wait_duration: 1s
    num_traces: 5000
    num_workers: 4
  memory_limiter:
    check_interval: 1s
    limit_mib: 1000
  k8sattributes:
    passthrough: false
    auth_type: "serviceAccount"
    pod_association:
      - sources:
          - from: resource_attribute
            name: k8s.pod.ip
    extract:
      metadata:
        - k8s.pod.name
        - k8s.pod.uid
        - k8s.deployment.name
        - k8s.node.name
        - k8s.namespace.name
        - k8s.pod.start_time
        - k8s.replicaset.name
        - k8s.replicaset.uid
        - k8s.daemonset.name
        - k8s.daemonset.uid
        - k8s.job.name
        - k8s.job.uid
        - k8s.cronjob.name
        - k8s.statefulset.name
        - k8s.statefulset.uid
        - container.image.name
        - container.image.tag
        - container.id
        - k8s.container.name
        - container.image.name
        - container.image.tag
        - container.id
      labels:
        - tag_name: kube_app_name
          key: app.kubernetes.io/name
          from: pod
        - tag_name: kube_app_instance
          key: app.kubernetes.io/instance
          from: pod
        - tag_name: kube_app_version
          key: app.kubernetes.io/version
          from: pod
        - tag_name: kube_app_component
          key: app.kubernetes.io/component
          from: pod
        - tag_name: kube_app_part_of
          key: app.kubernetes.io/part-of
          from: pod
        - tag_name: kube_app_managed_by
          key: app.kubernetes.io/managed-by
          from: pod
  resourcedetection:
    detectors: [ env, system ]
    timeout: 2s
    override: false
  metricstransform:
    transforms:
      include: .+
      match_type: regexp
      action: update
      operations:
        - action: add_label
          new_label: k8s.cluster.name
          new_value: minikube
        - action: add_label
          new_label: env
          new_value: prod
  # trace sampling to remove healthcheck calls
  tail_sampling:
    decision_wait: 10s
    #num_traces: 100
    #expected_new_traces_per_sec: 10
    policies:
      [
        {
          name: stop-health-checks,
          type: string_attribute,
          string_attribute: { key: http.target, values: [ \/health ],enabled_regex_matching: true, invert_match: true }
        },
        {
          name: stop-actuator-checks,
          type: string_attribute,
          string_attribute: { key: http.target, values: [ \/actuator ],enabled_regex_matching: true, invert_match: true }
        },
        {
          name: stop-hello-checks,
          type: string_attribute,
          string_attribute: { key: http.target, values: [ ApiController.hello ],enabled_regex_matching: true, invert_match: true }
        },
        {
          name: stop-prometheus-checks,
          type: string_attribute,
          string_attribute: { key: http.target, values: [ \/prometheus ],enabled_regex_matching: true, invert_match: true }
        }
      ]
exporters:
  logging:
    loglevel: info
  otlp/jaeger:
    endpoint: jaeger-collector.jaeger.svc.cluster.local:4317
    tls:
      insecure: true

extensions:
  health_check:

service:
  extensions: [health_check]
  telemetry:
    logs:
      level: "info"
  pipelines:
    logs:
      receivers: [ filelog, otlp ]
      processors: [ resource, memory_limiter, resourcedetection, k8sattributes, batch ]
      exporters: [ otlp/jaeger, logging ]
    traces:
      receivers: [ otlp ]
      processors: [ resource, memory_limiter, resourcedetection, tail_sampling, groupbytrace/custom, k8sattributes, batch ]
      exporters: [ otlp/jaeger, logging ]
#    metrics:
#      receivers: [ hostmetrics, otlp ]
#      processors: [ resource, resourcedetection, k8sattributes, batch ]
#      exporters: [ otlp/jaeger, logging ]