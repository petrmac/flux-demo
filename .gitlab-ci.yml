stages:
  - build
  - test
  - package
  - release

variables:
  REGISTRY: $CI_REGISTRY
  JAVA_IMAGE_NAME: $CI_REGISTRY_IMAGE/demo-service
  NODE_IMAGE_NAME: $CI_REGISTRY_IMAGE/node-service
  GRADLE_OPTS: "-Dorg.gradle.daemon=false"
  GRADLE_USER_HOME: $CI_PROJECT_DIR/.gradle

before_script:
  - echo "CI_COMMIT_BRANCH=$CI_COMMIT_BRANCH"
  - echo "CI_MERGE_REQUEST_ID=$CI_MERGE_REQUEST_ID"

cache:
  key: gradle-cache
  paths:
    - .gradle/wrapper
    - .gradle/caches

.java_service_changes:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - java-service/**
        - .gitlab-ci.yml
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - java-service/**
        - .gitlab-ci.yml
    - if: '$CI_PIPELINE_SOURCE == "web"'

build-java:
  stage: build
  image: eclipse-temurin:21-jdk
  extends: .java_service_changes
  before_script:
    - apt-get update && apt-get install -y git
  script:
    - cd java-service
    - chmod +x ./gradlew
    - ./gradlew build
  artifacts:
    paths:
      - java-service/build/
    reports:
      junit:
        - java-service/build/test-results/test/*.xml
    expire_in: 1 hour

test-java:
  stage: test
  image: eclipse-temurin:21-jdk
  extends: .java_service_changes
  needs: ["build-java"]
  script:
    - cd java-service
    - chmod +x ./gradlew
    - ./gradlew test
  artifacts:
    reports:
      junit:
        - java-service/build/test-results/test/*.xml

determine-version:
  stage: test
  image: eclipse-temurin:21-jdk
  extends: .java_service_changes
  needs: ["build-java"]
  before_script:
    - apt-get update && apt-get install -y git
  script:
    - cd java-service
    - chmod +x ./gradlew
    - |
      # Use Shipkit to determine the version
      ./gradlew -q printVersion > version.txt
      VERSION=$(cat version.txt | tr -d '\n')

      # If version is empty, read from version.properties
      if [ -z "$VERSION" ] || [ "$VERSION" == "unspecified" ]; then
        VERSION=$(grep "^version=" version.properties | cut -d'=' -f2)
      fi

      # For MR builds, add MR suffix
      if [ -n "$CI_MERGE_REQUEST_ID" ]; then
        VERSION="$VERSION-mr$CI_MERGE_REQUEST_ID"
      fi

      echo "VERSION=${VERSION}" > version.env
      echo "Generated version: ${VERSION}"
  artifacts:
    paths:
      - java-service/version.env
    reports:
      dotenv: java-service/version.env

build-docker:
  stage: package
  image: docker:24-cli
  services:
    - docker:24-dind
  extends: .java_service_changes
  needs: ["build-java", "test-java", "determine-version"]
  dependencies:
    - build-java
    - determine-version
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ""
    DOCKER_HOST: tcp://docker:2375
    DOCKER_BUILDKIT: 1
    BUILDKIT_PROGRESS: plain
  before_script:
    - source java-service/version.env
    - echo "Building version $VERSION"
  script:
    - |
      # Login to GitLab Container Registry
      # Try CI_JOB_TOKEN first (automatically provided), then fall back to deploy token or PAT
      if [ -n "$CI_JOB_TOKEN" ]; then
        echo "Logging in with CI_JOB_TOKEN"
        echo "$CI_JOB_TOKEN" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
      elif [ -n "$CI_DEPLOY_USER" ] && [ -n "$CI_DEPLOY_PASSWORD" ]; then
        echo "Logging in with deploy token"
        echo "$CI_DEPLOY_PASSWORD" | docker login -u "$CI_DEPLOY_USER" --password-stdin $CI_REGISTRY
      elif [ -n "$CI_REGISTRY_PASSWORD" ]; then
        echo "Logging in with registry credentials"
        echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
      else
        echo "Warning: No registry credentials found, attempting to proceed without login"
      fi

      # Setup Docker Buildx for multi-platform builds
      docker buildx ls
      docker buildx rm multiarch 2>/dev/null || true
      # Create builder with network host to ensure registry access
      docker buildx create --name multiarch --driver docker-container --driver-opt network=host --use
      docker buildx inspect --bootstrap

      # Build Docker image for multiple platforms with BuildKit caching
      if [ -z "$CI_MERGE_REQUEST_ID" ]; then
        # Build and push for non-MR pipelines
        docker buildx build \
          --platform linux/amd64,linux/arm64 \
          --build-arg VERSION=$VERSION \
          --build-arg COMMIT_SHA=$CI_COMMIT_SHA \
          --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
          -t $JAVA_IMAGE_NAME:$VERSION \
          -f java-service/Dockerfile \
          --push \
          java-service/
      else
        # Build only for MR pipelines
        docker buildx build \
          --platform linux/amd64,linux/arm64 \
          --build-arg VERSION=$VERSION \
          --build-arg COMMIT_SHA=$CI_COMMIT_SHA \
          --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
          -t $JAVA_IMAGE_NAME:$VERSION \
          -f java-service/Dockerfile \
          --output type=docker \
          java-service/
      fi

      # Tag and push latest if on main branch (only for non-MR pipelines)
      if [ "$CI_COMMIT_BRANCH" = "main" ] && [ -z "$CI_MERGE_REQUEST_ID" ]; then
        docker buildx build \
          --platform linux/amd64,linux/arm64 \
          -t $JAVA_IMAGE_NAME:latest \
          -f java-service/Dockerfile \
          --push \
          java-service/
      fi

# SBOM generation disabled - was failing in GitLab CI
# generate-sbom:
#   stage: package
#   image: anchore/syft:latest
#   extends: .java_service_changes
#   needs: ["build-docker", "determine-version"]
#   dependencies:
#     - determine-version
#   rules:
#     - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE != "merge_request_event"'
#       changes:
#         - java-service/**
#         - .gitlab-ci.yml
#   before_script:
#     - source java-service/version.env
#   script:
#     - |
#       syft $JAVA_IMAGE_NAME:$VERSION \
#         -o cyclonedx-json \
#         --file sbom.json
#   artifacts:
#     paths:
#       - sbom.json
#     expire_in: 30 days

check-release:
  stage: release
  image: eclipse-temurin:21-jdk
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      changes:
        - java-service/**
        - .gitlab-ci.yml
  before_script:
    - apt-get update && apt-get install -y git
  script:
    - cd java-service
    - chmod +x ./gradlew
    - |
      OUTPUT=$(./gradlew -q checkReleaseNeeded)
      echo "$OUTPUT"
      if echo "$OUTPUT" | grep -q "RELEASE_NEEDED=true"; then
        echo "RELEASE_NEEDED=true" > release.env
      else
        echo "RELEASE_NEEDED=false" > release.env
      fi
      cp release.env ../release.env
  artifacts:
    paths:
      - java-service/release.env
    reports:
      dotenv: java-service/release.env

create-release:
  stage: release
  image: eclipse-temurin:21-jdk
  rules:
    - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE == "push"'
      changes:
        - java-service/**
        - .gitlab-ci.yml
  needs: ["check-release", "build-docker"]
  dependencies:
    - check-release
  before_script:
    - apt-get update && apt-get install -y git
    - source java-service/release.env
  script:
    - |
      if [ "$RELEASE_NEEDED" = "true" ]; then
        cd java-service
        chmod +x ./gradlew

        # Create GitLab Release (requires GITLAB_TOKEN variable)
        if [ -n "$GITLAB_TOKEN" ]; then
          ./gradlew gitlabRelease -Pgitlab.token=$GITLAB_TOKEN
        else
          echo "Warning: GITLAB_TOKEN not set, skipping GitLab release creation"
        fi

        # Increment version for next release
        ./gradlew incrementVersion

        # Commit the version bump
        git config --global user.email "gitlab-ci[bot]@gitlab.com"
        git config --global user.name "gitlab-ci[bot]"

        if [ -f version.properties ]; then
          git remote set-url origin https://gitlab-ci-token:${GITLAB_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git
          git add version.properties
          NEW_VERSION=$(grep "^version=" version.properties | cut -d'=' -f2)
          git diff --staged --quiet || (git commit -m "chore: bump version to $NEW_VERSION [skip ci]" && git push origin HEAD:$CI_COMMIT_BRANCH)
        fi
      else
        echo "No release needed"
      fi

# ==================== Node Service Pipeline ====================

.node_service_changes:
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
      changes:
        - node-service/**
        - .gitlab-ci.yml
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - node-service/**
        - .gitlab-ci.yml
    - if: '$CI_PIPELINE_SOURCE == "web"'

build-node:
  stage: build
  image: node:20-alpine
  extends: .node_service_changes
  cache:
    key:
      files:
        - node-service/package-lock.json
    paths:
      - node-service/node_modules/
  script:
    - cd node-service
    - npm ci
    - npm run build
  artifacts:
    paths:
      - node-service/dist/
      - node-service/node_modules/
    expire_in: 1 hour

test-node:
  stage: test
  image: node:20-alpine
  extends: .node_service_changes
  needs: ["build-node"]
  dependencies:
    - build-node
  script:
    - cd node-service
    - npm test --if-present

determine-version-node:
  stage: test
  image: node:20-alpine
  extends: .node_service_changes
  needs: ["build-node"]
  before_script:
    - apk add --no-cache jq
  script:
    - cd node-service
    - |
      # Read version from version.json
      VERSION=$(cat version.json | jq -r '.version' 2>/dev/null || echo "1.0.0")

      # If version is empty, use package.json version
      if [ -z "$VERSION" ]; then
        VERSION=$(cat package.json | jq -r '.version' || echo "1.0.0")
      fi

      # For MR builds, add MR suffix
      if [ -n "$CI_MERGE_REQUEST_ID" ]; then
        VERSION="$VERSION-mr$CI_MERGE_REQUEST_ID"
      elif [ "$CI_COMMIT_BRANCH" != "main" ] && [ "$CI_COMMIT_BRANCH" != "master" ]; then
        # For non-main branches, add branch suffix
        BRANCH_NAME=$(echo $CI_COMMIT_BRANCH | sed 's/[^a-zA-Z0-9]/-/g')
        VERSION="$VERSION-$BRANCH_NAME"
      fi

      echo "VERSION=${VERSION}" > version.env
      echo "Generated version: ${VERSION}"
  artifacts:
    paths:
      - node-service/version.env
    reports:
      dotenv: node-service/version.env

build-docker-node:
  stage: package
  image: docker:24-cli
  services:
    - docker:24-dind
  extends: .node_service_changes
  needs: ["build-node", "test-node", "determine-version-node"]
  dependencies:
    - build-node
    - determine-version-node
  variables:
    DOCKER_DRIVER: overlay2
    DOCKER_TLS_CERTDIR: ""
    DOCKER_HOST: tcp://docker:2375
    DOCKER_BUILDKIT: 1
    BUILDKIT_PROGRESS: plain
  before_script:
    - source node-service/version.env
    - echo "Building version $VERSION"
  script:
    - |
      # Login to GitLab Container Registry
      # Try CI_JOB_TOKEN first (automatically provided), then fall back to deploy token or PAT
      if [ -n "$CI_JOB_TOKEN" ]; then
        echo "Logging in with CI_JOB_TOKEN"
        echo "$CI_JOB_TOKEN" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
      elif [ -n "$CI_DEPLOY_USER" ] && [ -n "$CI_DEPLOY_PASSWORD" ]; then
        echo "Logging in with deploy token"
        echo "$CI_DEPLOY_PASSWORD" | docker login -u "$CI_DEPLOY_USER" --password-stdin $CI_REGISTRY
      elif [ -n "$CI_REGISTRY_PASSWORD" ]; then
        echo "Logging in with registry credentials"
        echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin $CI_REGISTRY
      else
        echo "Warning: No registry credentials found, attempting to proceed without login"
      fi

      # Setup Docker Buildx for multi-platform builds
      docker buildx ls
      docker buildx rm multiarch 2>/dev/null || true
      # Create builder with network host to ensure registry access
      docker buildx create --name multiarch --driver docker-container --driver-opt network=host --use
      docker buildx inspect --bootstrap

      # Build Docker image for multiple platforms with BuildKit caching
      SHORT_SHA=$(echo $CI_COMMIT_SHA | cut -c1-8)
      DATE_TAG=$(date -u +'%Y.%m.%d')

      if [ -z "$CI_MERGE_REQUEST_ID" ]; then
        # Build and push for non-MR pipelines
        docker buildx build \
          --platform linux/amd64,linux/arm64 \
          --build-arg VERSION=$VERSION \
          --build-arg COMMIT_SHA=$CI_COMMIT_SHA \
          --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
          -t $NODE_IMAGE_NAME:$VERSION \
          -t $NODE_IMAGE_NAME:$DATE_TAG-$SHORT_SHA \
          -f node-service/Dockerfile \
          --push \
          node-service/
      else
        # Build only for MR pipelines
        docker buildx build \
          --platform linux/amd64,linux/arm64 \
          --build-arg VERSION=$VERSION \
          --build-arg COMMIT_SHA=$CI_COMMIT_SHA \
          --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ') \
          -t $NODE_IMAGE_NAME:$VERSION \
          -t $NODE_IMAGE_NAME:$DATE_TAG-$SHORT_SHA \
          -f node-service/Dockerfile \
          --output type=docker \
          node-service/
      fi

      # Tag and push latest if on main branch (only for non-MR pipelines)
      if [ "$CI_COMMIT_BRANCH" = "main" ] && [ -z "$CI_MERGE_REQUEST_ID" ]; then
        docker buildx build \
          --platform linux/amd64,linux/arm64 \
          -t $NODE_IMAGE_NAME:latest \
          -f node-service/Dockerfile \
          --push \
          node-service/
      fi

# SBOM generation disabled - was failing in GitLab CI
# generate-sbom-node:
#   stage: package
#   image: anchore/syft:latest
#   extends: .node_service_changes
#   needs: ["build-docker-node"]
#   rules:
#     - if: '$CI_COMMIT_BRANCH == "main" && $CI_PIPELINE_SOURCE != "merge_request_event"'
#       changes:
#         - node-service/**
#         - .gitlab-ci.yml
#   script:
#     - |
#       # Generate SBOM for Node service
#       syft dir:node-service \
#         -o spdx-json \
#         --file node-service-sbom.spdx.json
#   artifacts:
#     paths:
#       - node-service-sbom.spdx.json
#     expire_in: 30 days